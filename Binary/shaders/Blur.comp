#version 430 // Version of OpenGL with COMPUTE shader support

//MACROS
#define GROUP_SIZE		128
#define MAX_WEIGHTS		100
#define WEIGHT_COUNT	10

//Defines the groups sizes
layout (local_size_x = GROUP_SIZE, local_size_y = 1, local_size_z = 1) in;


layout (rgba32f) uniform readonly image2D src_img;		// READ ONLY  - Input image  - rgba32f img
layout (rgba32f) uniform writeonly image2D dst;			// WRITE ONLY - Output image - rgba32f img
uniform float weights[MAX_WEIGHTS];

// Variable shared by threads of this group.
// We write to this variable, and at the end, use this variable to fill dest
shared vec4 v[GROUP_SIZE + WEIGHT_COUNT - 1];


//////////////////
////   MAIN   ////
//////////////////
void main() 
{
    // ...
    
	// Position of the group in the whole image
    ivec2 global_pos = ivec2(gl_GlobalInvocationID.xy);

	// Local - thread index goes from 0 to GROUP_SIZE
    uint i = gl_LocalInvocationID.x;
    
	// Calculate the group's radius (not counting center value) 
	// TODO - pass as uniform
	int w = (WEIGHT_COUNT - 1) / 2;

	// Read a specific location from the image into v
	v[i] = imageLoad(src_img, global_pos + ivec2(i, 0));
    if (i < 2 * w)
        v[i + GROUP_SIZE] = imageLoad(src_img, global_pos + ivec2(GROUP_SIZE + i, 0));

	// Wait for all threads to catchup before reading v[]
    barrier();

    // Get data using v
	vec4 data;
	int realWeightCount = 2 * w;
	for(int j = 0; j < realWeightCount; ++j)
		data += weights[j] * v[i + j];

	//Finally, fill dst with data from v (I think)
    imageStore(dst, global_pos + ivec2(i, 0), data); // Write to destination image
}